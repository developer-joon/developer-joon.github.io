---
title: 'ì‹¤ì „ íŠ¸ë ˆì´ë”© ë´‡ ê³ ë„í™”: DCA 6ë‹¨ê³„ ë¬¼íƒ€ê¸° + ë‰´ìŠ¤ ê°ì„±ë¶„ì„ + ë™ì  í—¤ì§• ì „ëµ'
date: 2026-02-22 00:00:00
description: '-50% í­ë½ì—ë„ í‰ë‹¨ê°€ 76% ìœ ì§€í•˜ëŠ” 6ë‹¨ê³„ DCA ì „ëµ, ë‰´ìŠ¤ ê°ì„±ë¶„ì„ í•˜ì´ë¸Œë¦¬ë“œ ì‹œê·¸ë„, Bybit ì„ ë¬¼ ë™ì  í—¤ì§•ì„ ê²°í•©í•œ ì‹¤ì „ íŠ¸ë ˆì´ë”© ë´‡ ê°œë°œ ê°€ì´ë“œ. í˜„ì¬ PAPER ëª¨ë“œ ê²€ì¦ ì¤‘.'
featured_image: '/images/2026-02-22-Advanced-Trading-Bot-DCA-Strategy/cover.jpg'
---

![](/images/2026-02-22-Advanced-Trading-Bot-DCA-Strategy/cover.jpg)

## ë“¤ì–´ê°€ë©°

ê¸°ë³¸ íŠ¸ë ˆì´ë”© ë´‡ì„ ë§Œë“¤ê³  ì‹¤ì „ íˆ¬ì…í–ˆë‹¤ê°€ ì‹œì¥ ê¸‰ë½ìœ¼ë¡œ ê³ í†µë°›ì€ ê²½í—˜, ë‹¤ë“¤ ìˆìœ¼ì‹œì£ ? ë‹¨ìˆœ ì¶”ì„¸ ì¶”ì¢…ì´ë‚˜ ê·¸ë¦¬ë“œ ì „ëµë§Œìœ¼ë¡œëŠ” ë³€ë™ì„± ê·¹ì‹¬í•œ ì•”í˜¸í™”í ì‹œì¥ì—ì„œ ì‚´ì•„ë‚¨ê¸° ì–´ë µìŠµë‹ˆë‹¤.

ì´ ê¸€ì€ **ì‹¤ì „ì—ì„œ ê²€ì¦ ì¤‘ì¸ ê³ ê¸‰ íŠ¸ë ˆì´ë”© ë´‡ ì „ëµ**ì„ ë‹¤ë£¹ë‹ˆë‹¤. ê¸°ë³¸ ë´‡ ê°œë°œ ê°€ì´ë“œê°€ ê¶ê¸ˆí•˜ì‹œë‹¤ë©´ ë¨¼ì € [íŠ¸ë ˆì´ë”© ë´‡ ê°œë°œ ì™„ë²½ ê°€ì´ë“œ](/blog/trading-bot-development-guide)ë¥¼ ì½ì–´ë³´ì„¸ìš”.

### ì´ ê¸€ì—ì„œ ë‹¤ë£¨ëŠ” í•µì‹¬ ì „ëµ

1. **DCA 6ë‹¨ê³„ ë¬¼íƒ€ê¸° ì „ëµ** - í•˜ë½ ì‹œ ì ì§„ì  ì¶”ê°€ ë§¤ìˆ˜ë¡œ í‰ë‹¨ê°€ ê´€ë¦¬
2. **í•˜ì´ë¸Œë¦¬ë“œ ì‹œê·¸ë„** - 50% ëœë¤ + 50% ë‰´ìŠ¤ ê°ì„±ë¶„ì„ ì¡°í•©
3. **Phase ë¶„ë¦¬ ë°©ì–´ ì‹œìŠ¤í…œ** - DCA ì˜ˆì‚° ì†Œì§„ ì „í›„ ì „ëµ ì „í™˜
4. **15ë¶„ ê¸‰ë³€ ê°ì§€ ëª¨ë‹ˆí„°** - Â±3% ì´ìƒ ë³€ë™ ì¦‰ì‹œ ì•Œë¦¼
5. **ì§€ì •ê°€ ì£¼ë¬¸ ì‚¬ì „ë“±ë¡** - DCA + ìµì ˆ ì£¼ë¬¸ ë¯¸ë¦¬ ê±¸ì–´ë‘ê¸°
6. **Bybit ì„ ë¬¼ ë™ì  í—¤ì§•** - ì‹œì¥ ìƒí™©ë³„ í—¤ì§€ ë¹„ìœ¨ ìë™ ì¡°ì ˆ
7. **4ì‹œê°„ ì£¼ê¸° ë‰´ìŠ¤ ë¶„ì„** - í•˜ë£¨ 6íšŒ ìë™ ì‹œê·¸ë„ ìƒì„±

> âš ï¸ **í˜„ì¬ ìƒíƒœ**: ë³¸ ì „ëµì€ PAPER ëª¨ë“œ(ëª¨ì˜ë§¤ë§¤)ë¡œ ê²€ì¦ ì¤‘ì…ë‹ˆë‹¤. ì‹¤ê³„ì¢Œ íˆ¬ì… ì „ ì¶©ë¶„í•œ ê²€ì¦ ê¸°ê°„ì´ í•„ìš”í•©ë‹ˆë‹¤.

---

## DCA 6ë‹¨ê³„ ë¬¼íƒ€ê¸° ì „ëµì´ë€?

![](/images/2026-02-22-Advanced-Trading-Bot-DCA-Strategy/dca-concept.jpg)

DCA(Dollar Cost Averaging)ëŠ” **ê°€ê²© í•˜ë½ ì‹œ ì ì§„ì ìœ¼ë¡œ ì¶”ê°€ ë§¤ìˆ˜**í•˜ì—¬ í‰ê·  ë‹¨ê°€ë¥¼ ë‚®ì¶”ëŠ” ì „ëµì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ë¬´ì‘ì • ë¬¼íƒ€ê¸°í•˜ë©´ ìê¸ˆì´ ê¸ˆë°© ê³ ê°ˆë©ë‹ˆë‹¤.

### 6ë‹¨ê³„ ë¬¼íƒ€ê¸° ìˆ˜í•™ì  ì›ë¦¬

```
ì´ˆê¸° ë§¤ìˆ˜: 100ë§Œì› @ 100ì› (10,000ì½”ì¸)

í•˜ë½ë¥     ì¶”ê°€ ë§¤ìˆ˜ì•¡    ëˆ„ì  íˆ¬ì    í‰ê·  ë‹¨ê°€    ì†ìµë¶„ê¸°ì 
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
 -5%      20ë§Œì›        120ë§Œì›       95.2ì›       +5.0%
-10%      30ë§Œì›        150ë§Œì›       90.9ì›      +10.0%
-20%      50ë§Œì›        200ë§Œì›       83.3ì›      +20.0%
-30%      70ë§Œì›        270ë§Œì›       77.1ì›      +29.7%
-40%     100ë§Œì›        370ë§Œì›       71.2ì›      +40.4%
-50%     150ë§Œì›        520ë§Œì›       76.5ì›      +30.7%
```

**í•µì‹¬ í¬ì¸íŠ¸**: -50% í­ë½ ìƒí™©ì—ì„œë„ í‰ë‹¨ê°€ëŠ” 76.5ì›(ì´ˆê¸° ëŒ€ë¹„ -23.5%)ìœ¼ë¡œ ê´€ë¦¬ë©ë‹ˆë‹¤. ì‹œì¥ì´ 80ì›ë§Œ íšŒë³µí•´ë„ ìµì ˆ ê°€ëŠ¥!

### ë¬¼íƒ€ê¸° ì „ëµ ì½”ë“œ êµ¬í˜„

```python
# src/dca_strategy.py
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class DCALevel:
    """DCA ë‹¨ê³„ ì •ì˜"""
    level: int
    trigger_drop_pct: float  # í•˜ë½ë¥  (ì˜ˆ: -5%)
    buy_ratio: float         # ì´ˆê¸° íˆ¬ì ëŒ€ë¹„ ì¶”ê°€ ë§¤ìˆ˜ ë¹„ìœ¨ (ì˜ˆ: 0.2 = 20%)
    executed: bool = False
    executed_price: Optional[float] = None
    executed_amount: Optional[float] = None

class DCAManager:
    def __init__(self, initial_capital: float, base_price: float):
        """
        initial_capital: ì´ DCA ì˜ˆì‚°
        base_price: ì´ˆê¸° ì§„ì…ê°€
        """
        self.total_budget = initial_capital
        self.base_price = base_price
        self.base_investment = initial_capital * 0.192  # ì´ˆê¸° íˆ¬ì 19.2% (ì´ 6ë‹¨ê³„ ê· í˜•)
        
        # 6ë‹¨ê³„ DCA ë ˆë²¨ ì •ì˜
        self.levels: List[DCALevel] = [
            DCALevel(1, -5.0, 0.20),   # -5%: ì´ˆê¸° íˆ¬ìì˜ 20%
            DCALevel(2, -10.0, 0.30),  # -10%: 30%
            DCALevel(3, -20.0, 0.50),  # -20%: 50%
            DCALevel(4, -30.0, 0.70),  # -30%: 70%
            DCALevel(5, -40.0, 1.00),  # -40%: 100%
            DCALevel(6, -50.0, 1.50),  # -50%: 150%
        ]
        
        self.total_invested = self.base_investment
        self.total_coins = self.base_investment / base_price
        self.remaining_budget = self.total_budget - self.base_investment

    def check_trigger(self, current_price: float) -> Optional[DCALevel]:
        """í˜„ì¬ê°€ ê¸°ì¤€ìœ¼ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œ DCA ë ˆë²¨ í™•ì¸"""
        drop_pct = (current_price - self.base_price) / self.base_price * 100
        
        for level in self.levels:
            if not level.executed and drop_pct <= level.trigger_drop_pct:
                return level
        
        return None

    def execute_dca(self, level: DCALevel, current_price: float) -> dict:
        """DCA ë ˆë²¨ ì‹¤í–‰"""
        buy_amount = self.base_investment * level.buy_ratio
        
        if buy_amount > self.remaining_budget:
            buy_amount = self.remaining_budget  # ë‚¨ì€ ì˜ˆì‚°ë§Œ ì‚¬ìš©
        
        coins_to_buy = buy_amount / current_price
        
        # ìƒíƒœ ì—…ë°ì´íŠ¸
        level.executed = True
        level.executed_price = current_price
        level.executed_amount = coins_to_buy
        
        self.total_invested += buy_amount
        self.total_coins += coins_to_buy
        self.remaining_budget -= buy_amount
        
        avg_price = self.total_invested / self.total_coins
        
        return {
            'level': level.level,
            'trigger_drop': level.trigger_drop_pct,
            'buy_amount': buy_amount,
            'buy_price': current_price,
            'coins_bought': coins_to_buy,
            'total_coins': self.total_coins,
            'avg_price': avg_price,
            'total_invested': self.total_invested,
            'remaining_budget': self.remaining_budget,
        }

    def get_avg_price(self) -> float:
        """í˜„ì¬ í‰ê·  ë‹¨ê°€"""
        return self.total_invested / self.total_coins if self.total_coins > 0 else 0

    def is_budget_exhausted(self) -> bool:
        """DCA ì˜ˆì‚° ì†Œì§„ ì—¬ë¶€"""
        return self.remaining_budget < self.base_investment * 0.1  # 10% ë¯¸ë§Œ ë‚¨ìœ¼ë©´ ì†Œì§„ìœ¼ë¡œ ê°„ì£¼
```

---

## í•˜ì´ë¸Œë¦¬ë“œ ì‹œê·¸ë„: ëœë¤ 50% + ë‰´ìŠ¤ ê°ì„±ë¶„ì„ 50%

![](/images/2026-02-22-Advanced-Trading-Bot-DCA-Strategy/hybrid-signal.jpg)

ë‹¨ì¼ ì‹œê·¸ë„ ì†ŒìŠ¤ëŠ” í¸í–¥ì„ ë§Œë“­ë‹ˆë‹¤. ë‰´ìŠ¤ë§Œ ë³´ë©´ ê³¼ë„í•œ ê³µí¬ì—, ê¸°ìˆ ì  ì§€í‘œë§Œ ë³´ë©´ ì‹œì¥ ì‹¬ë¦¬ë¥¼ ë†“ì¹©ë‹ˆë‹¤. **í•˜ì´ë¸Œë¦¬ë“œ ì‹œê·¸ë„**ì€ ë‘ ê°€ì§€ë¥¼ ê· í˜•ìˆê²Œ ì¡°í•©í•©ë‹ˆë‹¤.

### ì™œ ëœë¤ì„ í¬í•¨í•˜ëŠ”ê°€?

ì—­ì„¤ì ìœ¼ë¡œ ë“¤ë¦¬ì§€ë§Œ, **ì™„ì „ ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì „ëµì€ ì‹œì¥ì—ì„œ ì°©ì·¨ë‹¹í•©ë‹ˆë‹¤**. ëœë¤ ìš”ì†ŒëŠ”:
- íŒ¨í„´ ì˜ˆì¸¡ì„ ì–´ë µê²Œ ë§Œë“¦
- ê³¼ìµœì í™”(overfitting) ë°©ì§€
- ì¥ê¸°ì ìœ¼ë¡œ ì‹œì¥ í‰ê·  ìˆ˜ìµë¥  ì¶”ì¢…

### ë‰´ìŠ¤ ê°ì„±ë¶„ì„ êµ¬í˜„

```python
# src/news_sentiment.py
import anthropic
import os
from typing import List, Dict
from datetime import datetime

class NewsSentimentAnalyzer:
    def __init__(self):
        self.client = anthropic.Anthropic(api_key=os.getenv("ANTHROPIC_API_KEY"))
        self.model = "claude-3-5-sonnet-20241022"
    
    def analyze_crypto_news(self, news_list: List[Dict]) -> float:
        """
        ë‰´ìŠ¤ ë¦¬ìŠ¤íŠ¸ ê°ì„± ë¶„ì„
        
        Args:
            news_list: [{'title': str, 'summary': str, 'source': str}, ...]
        
        Returns:
            float: -1.0 (ë§¤ìš° ë¶€ì •) ~ +1.0 (ë§¤ìš° ê¸ì •)
        """
        news_text = "\n\n".join([
            f"[{news['source']}] {news['title']}\n{news.get('summary', '')}"
            for news in news_list
        ])
        
        prompt = f"""ë‹¤ìŒì€ ìµœê·¼ 4ì‹œê°„ ë™ì•ˆì˜ ì•”í˜¸í™”í ê´€ë ¨ ë‰´ìŠ¤ì…ë‹ˆë‹¤.

{news_text}

ìœ„ ë‰´ìŠ¤ë“¤ì„ ì¢…í•©ì ìœ¼ë¡œ ë¶„ì„í•˜ì—¬ ì•”í˜¸í™”í ì‹œì¥ ì „ë°˜ì— ëŒ€í•œ ê°ì„± ì ìˆ˜ë¥¼ -1.0ì—ì„œ +1.0 ì‚¬ì´ë¡œ í‰ê°€í•´ì£¼ì„¸ìš”.

- +1.0: ë§¤ìš° ê¸ì •ì  (ê°•ë ¥í•œ ìƒìŠ¹ ì‹ í˜¸)
- +0.5: ê¸ì •ì  (ì˜¨ê±´í•œ ìƒìŠ¹ ê¸°ëŒ€)
- 0.0: ì¤‘ë¦½
- -0.5: ë¶€ì •ì  (í•˜ë½ ìš°ë ¤)
- -1.0: ë§¤ìš° ë¶€ì •ì  (ê°•ë ¥í•œ í•˜ë½ ì‹ í˜¸)

ë¶„ì„ ì‹œ ê³ ë ¤ì‚¬í•­:
1. ê·œì œ/ì •ì±… ë‰´ìŠ¤ì˜ ì˜í–¥ë ¥
2. ì£¼ìš” ê±°ë˜ì†ŒÂ·ê¸°ì—…ì˜ ë™í–¥
3. ê¸°ìˆ ì  ë°œì „ vs ë³´ì•ˆ ì‚¬ê³ 
4. ê±°ì‹œê²½ì œ ì§€í‘œì™€ì˜ ì—°ê´€ì„±
5. ê³¼ì¥ëœ í‘œí˜„ vs ì‹¤ì§ˆì  ì˜í–¥

ì‘ë‹µ í˜•ì‹: ìˆ«ìë§Œ ì¶œë ¥ (ì˜ˆ: 0.3)"""

        response = self.client.messages.create(
            model=self.model,
            max_tokens=50,
            messages=[{"role": "user", "content": prompt}]
        )
        
        try:
            score = float(response.content[0].text.strip())
            return max(-1.0, min(1.0, score))  # ë²”ìœ„ ì œí•œ
        except ValueError:
            return 0.0  # íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì¤‘ë¦½

class HybridSignalGenerator:
    def __init__(self, news_analyzer: NewsSentimentAnalyzer):
        self.news_analyzer = news_analyzer
        self.last_news_check = None
        self.cached_sentiment = 0.0
    
    def generate_signal(self, news_list: List[Dict] = None) -> str:
        """
        í•˜ì´ë¸Œë¦¬ë“œ ì‹œê·¸ë„ ìƒì„±
        
        Returns:
            'BUY', 'SELL', 'HOLD'
        """
        import random
        
        # 1. ëœë¤ ì‹œê·¸ë„ (50%)
        random_value = random.uniform(-1, 1)
        
        # 2. ë‰´ìŠ¤ ê°ì„± ì‹œê·¸ë„ (50%)
        if news_list:
            sentiment = self.news_analyzer.analyze_crypto_news(news_list)
            self.cached_sentiment = sentiment
        else:
            sentiment = self.cached_sentiment
        
        # 3. í•˜ì´ë¸Œë¦¬ë“œ ì ìˆ˜ (í‰ê· )
        hybrid_score = (random_value + sentiment) / 2
        
        # 4. ì‹œê·¸ë„ ë³€í™˜ (ì„ê³„ê°’ ê¸°ë°˜)
        if hybrid_score > 0.2:
            return 'BUY'
        elif hybrid_score < -0.2:
            return 'SELL'
        else:
            return 'HOLD'
```

### ë‰´ìŠ¤ ìˆ˜ì§‘ ìë™í™”

```python
# src/news_collector.py
import feedparser
from datetime import datetime, timedelta
from typing import List, Dict

class CryptoNewsCollector:
    def __init__(self):
        self.rss_feeds = [
            'https://cointelegraph.com/rss',
            'https://www.coindesk.com/arc/outboundfeeds/rss/',
            'https://decrypt.co/feed',
            # ì¶”ê°€ í”¼ë“œ...
        ]
    
    def fetch_recent_news(self, hours: int = 4) -> List[Dict]:
        """ìµœê·¼ Nì‹œê°„ ë‰´ìŠ¤ ìˆ˜ì§‘"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        all_news = []
        
        for feed_url in self.rss_feeds:
            try:
                feed = feedparser.parse(feed_url)
                for entry in feed.entries:
                    pub_date = datetime(*entry.published_parsed[:6])
                    
                    if pub_date >= cutoff_time:
                        all_news.append({
                            'title': entry.title,
                            'summary': entry.get('summary', '')[:300],
                            'source': feed.feed.title,
                            'published': pub_date.isoformat(),
                        })
            except Exception as e:
                print(f"í”¼ë“œ ìˆ˜ì§‘ ì‹¤íŒ¨ {feed_url}: {e}")
        
        # ìµœì‹ ìˆœ ì •ë ¬
        all_news.sort(key=lambda x: x['published'], reverse=True)
        return all_news[:20]  # ìµœëŒ€ 20ê°œ
```

---

## Phase ë¶„ë¦¬ ë°©ì–´ ì‹œìŠ¤í…œ

![](/images/2026-02-22-Advanced-Trading-Bot-DCA-Strategy/defense-phase.jpg)

DCA ì˜ˆì‚°ì´ ìˆì„ ë•Œì™€ ì†Œì§„ëì„ ë•ŒëŠ” **ì™„ì „íˆ ë‹¤ë¥¸ ì „ëµ**ì´ í•„ìš”í•©ë‹ˆë‹¤.

### Phase 1: DCA ì˜ˆì‚° ë³´ìœ  ë‹¨ê³„

- **ì „ëµ**: ë¬¼íƒ€ê¸°ë§Œ ì§„í–‰ (ì¶”ê°€ ë°©ì–´ ì—†ìŒ)
- **ë…¼ë¦¬**: í•˜ë½ = í‰ë‹¨ê°€ë¥¼ ë‚®ì¶œ ê¸°íšŒ
- **ì•¡ì…˜**: DCA ë ˆë²¨ë§Œ ì²´í¬, ë°©ì–´ ì •ì±…ì€ ë¹„í™œì„±

### Phase 2: DCA ì˜ˆì‚° ì†Œì§„ ë‹¨ê³„

- **ì „ëµ**: í‰ë‹¨ê°€ ê¸°ì¤€ ì ê·¹ ë°©ì–´
- **ë…¼ë¦¬**: ë” ì´ìƒ ë¬¼íƒˆ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì†ì‹¤ í™•ëŒ€ ì°¨ë‹¨
- **ì•¡ì…˜**:
  - **-3% ì•Œë¦¼**: í…”ë ˆê·¸ë¨ ì•Œë¦¼ë§Œ ë°œì†¡ (ìˆ˜ë™ íŒë‹¨ ì—¬ì§€)
  - **-5% 50% ê°ì¶•**: í¬ì§€ì…˜ ì ˆë°˜ ìë™ ì²­ì‚°
  - **-8% ì „ëŸ‰ ì²­ì‚°**: ë‚¨ì€ í¬ì§€ì…˜ ì „ëŸ‰ ì²­ì‚° + ë´‡ ì¤‘ì§€

### êµ¬í˜„ ì½”ë“œ

```python
# src/phase_defense.py
from enum import Enum
from loguru import logger

class TradingPhase(Enum):
    DCA_ACTIVE = "DCA_ACTIVE"       # DCA ì˜ˆì‚° ìˆìŒ
    DCA_EXHAUSTED = "DCA_EXHAUSTED" # DCA ì˜ˆì‚° ì†Œì§„, ë°©ì–´ ëª¨ë“œ

class PhaseDefenseManager:
    def __init__(self, dca_manager, notifier):
        self.dca_manager = dca_manager
        self.notifier = notifier
        self.phase = TradingPhase.DCA_ACTIVE
        self.alert_sent_3pct = False
        self.reduced_at_5pct = False
    
    def update_phase(self):
        """í˜„ì¬ Phase ì—…ë°ì´íŠ¸"""
        if self.dca_manager.is_budget_exhausted():
            if self.phase != TradingPhase.DCA_EXHAUSTED:
                self.phase = TradingPhase.DCA_EXHAUSTED
                self.notifier.send(
                    "âš ï¸ <b>Phase ì „í™˜</b>\n\n"
                    "DCA ì˜ˆì‚° ì†Œì§„ â†’ ë°©ì–´ ëª¨ë“œ ì§„ì…\n"
                    "í‰ë‹¨ê°€ ê¸°ì¤€ -3%/-5%/-8% ë°©ì–´ ì •ì±… í™œì„±í™”"
                )
                logger.warning("Phase ì „í™˜: DCA_ACTIVE -> DCA_EXHAUSTED")
    
    def check_defense_trigger(self, current_price: float, position_size: float) -> dict:
        """ë°©ì–´ ì •ì±… ì²´í¬ (Phase 2ì—ì„œë§Œ ë™ì‘)"""
        if self.phase != TradingPhase.DCA_EXHAUSTED:
            return {'action': 'NONE'}
        
        avg_price = self.dca_manager.get_avg_price()
        drop_from_avg = (current_price - avg_price) / avg_price * 100
        
        # -8% ì „ëŸ‰ ì²­ì‚°
        if drop_from_avg <= -8.0:
            self.notifier.send(
                f"ğŸš¨ <b>ê¸´ê¸‰ ì²­ì‚° ì‹¤í–‰</b>\n\n"
                f"í‰ë‹¨ê°€ ëŒ€ë¹„: {drop_from_avg:.2f}%\n"
                f"í˜„ì¬ê°€: {current_price:,.0f}ì›\n"
                f"í‰ë‹¨ê°€: {avg_price:,.0f}ì›\n\n"
                f"í¬ì§€ì…˜ ì „ëŸ‰ ì²­ì‚° + ë´‡ ì¤‘ì§€"
            )
            return {
                'action': 'LIQUIDATE_ALL',
                'reason': f'í‰ë‹¨ê°€ ëŒ€ë¹„ {drop_from_avg:.2f}% í•˜ë½',
                'sell_ratio': 1.0
            }
        
        # -5% 50% ê°ì¶•
        if drop_from_avg <= -5.0 and not self.reduced_at_5pct:
            self.reduced_at_5pct = True
            self.notifier.send(
                f"âš ï¸ <b>í¬ì§€ì…˜ 50% ê°ì¶•</b>\n\n"
                f"í‰ë‹¨ê°€ ëŒ€ë¹„: {drop_from_avg:.2f}%\n"
                f"í˜„ì¬ê°€: {current_price:,.0f}ì›\n"
                f"í‰ë‹¨ê°€: {avg_price:,.0f}ì›"
            )
            return {
                'action': 'REDUCE_POSITION',
                'reason': f'í‰ë‹¨ê°€ ëŒ€ë¹„ {drop_from_avg:.2f}% í•˜ë½',
                'sell_ratio': 0.5
            }
        
        # -3% ì•Œë¦¼
        if drop_from_avg <= -3.0 and not self.alert_sent_3pct:
            self.alert_sent_3pct = True
            self.notifier.send(
                f"âš¡ <b>í•˜ë½ ì•Œë¦¼</b>\n\n"
                f"í‰ë‹¨ê°€ ëŒ€ë¹„: {drop_from_avg:.2f}%\n"
                f"í˜„ì¬ê°€: {current_price:,.0f}ì›\n"
                f"í‰ë‹¨ê°€: {avg_price:,.0f}ì›\n\n"
                f"ì¶”ê°€ í•˜ë½ ì‹œ -5%ì—ì„œ 50% ê°ì¶• ì˜ˆì •"
            )
        
        return {'action': 'NONE'}
```

---

## 15ë¶„ ê¸‰ë³€ ê°ì§€ ëª¨ë‹ˆí„°

![](/images/2026-02-22-Advanced-Trading-Bot-DCA-Strategy/volatility-monitor.jpg)

ì•”í˜¸í™”í ì‹œì¥ì€ 15ë¶„ ë§Œì— Â±5% ì›€ì§ì´ëŠ” ì¼ì´ í”í•©ë‹ˆë‹¤. ê¸‰ë³€ ì‹œ **ì¦‰ì‹œ ì•Œë¦¼**ì„ ë°›ì•„ ìˆ˜ë™ ê°œì… ì—¬ì§€ë¥¼ ë§Œë“­ë‹ˆë‹¤.

```python
# src/volatility_monitor.py
from collections import deque
from datetime import datetime
from loguru import logger

class VolatilityMonitor:
    def __init__(self, threshold_pct: float = 3.0, window_minutes: int = 15):
        """
        threshold_pct: ì•Œë¦¼ ë°œë™ ë³€ë™ë¥  (ì˜ˆ: 3.0 = Â±3%)
        window_minutes: ê°ì‹œ ì‹œê°„ ì°½ (ë¶„)
        """
        self.threshold = threshold_pct
        self.window_minutes = window_minutes
        self.price_history = deque(maxlen=window_minutes)  # ìµœê·¼ 15ë¶„ ê°€ê²©
    
    def update(self, current_price: float) -> dict:
        """
        ê°€ê²© ì—…ë°ì´íŠ¸ ë° ê¸‰ë³€ ê°ì§€
        
        Returns:
            {'alert': bool, 'change_pct': float, 'direction': str}
        """
        now = datetime.now()
        self.price_history.append({'time': now, 'price': current_price})
        
        if len(self.price_history) < 2:
            return {'alert': False}
        
        # 15ë¶„ ì „ ê°€ê²©ê³¼ ë¹„êµ
        oldest_price = self.price_history[0]['price']
        change_pct = (current_price - oldest_price) / oldest_price * 100
        
        if abs(change_pct) >= self.threshold:
            direction = "ìƒìŠ¹" if change_pct > 0 else "í•˜ë½"
            logger.warning(f"ê¸‰ë³€ ê°ì§€: {change_pct:+.2f}% ({direction})")
            
            return {
                'alert': True,
                'change_pct': change_pct,
                'direction': direction,
                'old_price': oldest_price,
                'new_price': current_price,
            }
        
        return {'alert': False}

# ë©”ì¸ ë£¨í”„ì— í†µí•©
def monitor_loop(exchange, volatility_monitor, notifier):
    """1ë¶„ë§ˆë‹¤ ì‹¤í–‰"""
    current_price = exchange.get_ticker('BTC/USDT')['last']
    result = volatility_monitor.update(current_price)
    
    if result['alert']:
        emoji = "ğŸš€" if result['change_pct'] > 0 else "âš¡"
        notifier.send(
            f"{emoji} <b>15ë¶„ ê¸‰ë³€ ê°ì§€!</b>\n\n"
            f"ë³€ë™í­: {result['change_pct']:+.2f}%\n"
            f"ë°©í–¥: {result['direction']}\n"
            f"ì´ì „: {result['old_price']:,.0f}ì›\n"
            f"í˜„ì¬: {result['new_price']:,.0f}ì›"
        )
```

---

## ì§€ì •ê°€ ì£¼ë¬¸ ì‚¬ì „ë“±ë¡

![](/images/2026-02-22-Advanced-Trading-Bot-DCA-Strategy/limit-orders.jpg)

**ë„¤íŠ¸ì›Œí¬ ì§€ì—°**ì´ë‚˜ **API ì¥ì• ** ì‹œì—ë„ ì£¼ë¬¸ì´ ì‹¤í–‰ë˜ë„ë¡, DCA ë¬¼íƒ€ê¸°ì™€ ìµì ˆ ì£¼ë¬¸ì„ **ë¯¸ë¦¬ ê±¸ì–´ë‘¡ë‹ˆë‹¤**.

### ì¥ì 

- âš¡ ì¦‰ì‹œ ì²´ê²° (API í˜¸ì¶œ ì§€ì—° ì—†ìŒ)
- ğŸ›¡ï¸ ë´‡ ì¥ì•  ì‹œì—ë„ ì£¼ë¬¸ ìœ ì§€
- ğŸ’° Maker ìˆ˜ìˆ˜ë£Œ ì ìš© (ê±°ë˜ì†Œì— ë”°ë¼ ìˆ˜ìˆ˜ë£Œ í• ì¸)

### êµ¬í˜„

```python
# src/order_manager.py
from typing import List, Dict

class LimitOrderManager:
    def __init__(self, exchange):
        self.exchange = exchange
        self.active_orders: List[str] = []  # ì£¼ë¬¸ ID ëª©ë¡
    
    def register_dca_orders(self, symbol: str, dca_manager) -> List[Dict]:
        """DCA ë¬¼íƒ€ê¸° ì£¼ë¬¸ ì‚¬ì „ ë“±ë¡"""
        orders = []
        
        for level in dca_manager.levels:
            if level.executed:
                continue
            
            # íŠ¸ë¦¬ê±° ê°€ê²© ê³„ì‚°
            trigger_price = dca_manager.base_price * (1 + level.trigger_drop_pct / 100)
            buy_amount_usd = dca_manager.base_investment * level.buy_ratio
            buy_quantity = buy_amount_usd / trigger_price
            
            try:
                order = self.exchange.create_limit_buy_order(
                    symbol=symbol,
                    amount=buy_quantity,
                    price=trigger_price
                )
                
                self.active_orders.append(order['id'])
                orders.append({
                    'level': level.level,
                    'order_id': order['id'],
                    'price': trigger_price,
                    'amount': buy_quantity,
                })
                
                logger.info(f"DCA Level {level.level} ì§€ì •ê°€ ì£¼ë¬¸ ë“±ë¡: {trigger_price:,.0f}ì›")
            
            except Exception as e:
                logger.error(f"ì§€ì •ê°€ ì£¼ë¬¸ ì‹¤íŒ¨: {e}")
        
        return orders
    
    def register_take_profit_orders(self, symbol: str, avg_price: float, 
                                     total_coins: float, targets: List[float]) -> List[Dict]:
        """ìµì ˆ ì£¼ë¬¸ ì‚¬ì „ ë“±ë¡ (ë¶„í•  ìµì ˆ)"""
        orders = []
        coins_per_target = total_coins / len(targets)
        
        for i, profit_pct in enumerate(targets):
            target_price = avg_price * (1 + profit_pct / 100)
            
            try:
                order = self.exchange.create_limit_sell_order(
                    symbol=symbol,
                    amount=coins_per_target,
                    price=target_price
                )
                
                self.active_orders.append(order['id'])
                orders.append({
                    'target': f'+{profit_pct}%',
                    'order_id': order['id'],
                    'price': target_price,
                    'amount': coins_per_target,
                })
                
                logger.info(f"ìµì ˆ ì£¼ë¬¸ ë“±ë¡ (+{profit_pct}%): {target_price:,.0f}ì›")
            
            except Exception as e:
                logger.error(f"ìµì ˆ ì£¼ë¬¸ ì‹¤íŒ¨: {e}")
        
        return orders
    
    def cancel_all_orders(self):
        """ëª¨ë“  ë¯¸ì²´ê²° ì£¼ë¬¸ ì·¨ì†Œ"""
        for order_id in self.active_orders:
            try:
                self.exchange.cancel_order(order_id)
            except:
                pass
        self.active_orders.clear()
```

### ì‚¬ìš© ì˜ˆì‹œ

```python
# ì´ˆê¸° ì§„ì… í›„
order_manager.register_dca_orders('BTC/USDT', dca_manager)
order_manager.register_take_profit_orders(
    'BTC/USDT',
    avg_price=50_000_000,
    total_coins=0.02,
    targets=[5, 10, 15, 20]  # +5%, +10%, +15%, +20% ë¶„í•  ìµì ˆ
)
```

---

## Bybit ì„ ë¬¼ ë™ì  í—¤ì§• ì „ëµ

![](/images/2026-02-22-Advanced-Trading-Bot-DCA-Strategy/hedging.jpg)

í˜„ë¬¼ í¬ì§€ì…˜ë§Œ ë³´ìœ í•˜ë©´ í•˜ë½ì¥ì—ì„œ ì†ìˆ˜ë¬´ì±…ì…ë‹ˆë‹¤. **Bybit ì„ ë¬¼ë¡œ í—¤ì§€**í•˜ì—¬ ë¦¬ìŠ¤í¬ë¥¼ ë¶„ì‚°í•©ë‹ˆë‹¤.

### ì‹œì¥ ìƒí™©ë³„ í—¤ì§€ ë¹„ìœ¨

| ì‹œì¥ ë¶„ìœ„ê¸° | ë‰´ìŠ¤ ê°ì„± ì ìˆ˜ | í—¤ì§€ ë¹„ìœ¨ | ë…¼ë¦¬ |
|------------|----------------|-----------|------|
| ğŸ‚ BULLISH | +0.5 ~ +1.0 | 0~20% | ìƒìŠ¹ì¥, ìµœì†Œ í—¤ì§€ |
| ğŸ˜ NEUTRAL | -0.5 ~ +0.5 | 40~60% | íš¡ë³´ì¥, ì¤‘ë¦½ í—¤ì§€ |
| ğŸ» BEARISH | -1.0 ~ -0.5 | 80~100% | í•˜ë½ì¥, ì ê·¹ í—¤ì§€ |

### í—¤ì§• ë¡œì§

```python
# src/hedging_manager.py
import ccxt

class BybitHedgingManager:
    def __init__(self, api_key: str, api_secret: str):
        self.exchange = ccxt.bybit({
            'apiKey': api_key,
            'secret': api_secret,
            'options': {'defaultType': 'future'},  # ì„ ë¬¼ ê±°ë˜
        })
    
    def calculate_hedge_ratio(self, sentiment_score: float) -> float:
        """
        ë‰´ìŠ¤ ê°ì„± ì ìˆ˜ë¡œ í—¤ì§€ ë¹„ìœ¨ ê³„ì‚°
        
        Args:
            sentiment_score: -1.0 ~ +1.0
        
        Returns:
            0.0 ~ 1.0 (í—¤ì§€ ë¹„ìœ¨)
        """
        if sentiment_score >= 0.5:
            # BULLISH: 0~20% í—¤ì§€
            return 0.0 + (0.5 - sentiment_score) * 0.4  # 0~0.2
        elif sentiment_score <= -0.5:
            # BEARISH: 80~100% í—¤ì§€
            return 0.8 + (-0.5 - sentiment_score) * 0.4  # 0.8~1.0
        else:
            # NEUTRAL: 40~60% í—¤ì§€ (ì„ í˜• ë³´ê°„)
            return 0.4 + (0.5 - sentiment_score) * 0.2  # 0.4~0.6
    
    def adjust_hedge_position(self, symbol: str, spot_position_value: float, 
                               target_hedge_ratio: float):
        """
        í—¤ì§€ í¬ì§€ì…˜ ì¡°ì • (Short ì„ ë¬¼)
        
        Args:
            symbol: 'BTC/USDT:USDT' (Bybit ì˜êµ¬ì„ ë¬¼)
            spot_position_value: í˜„ë¬¼ í¬ì§€ì…˜ ê°€ì¹˜ (USDT)
            target_hedge_ratio: ëª©í‘œ í—¤ì§€ ë¹„ìœ¨ (0.0~1.0)
        """
        target_short_value = spot_position_value * target_hedge_ratio
        
        # í˜„ì¬ ì„ ë¬¼ í¬ì§€ì…˜ ì¡°íšŒ
        positions = self.exchange.fetch_positions([symbol])
        current_short_value = 0
        
        for pos in positions:
            if pos['side'] == 'short':
                current_short_value = abs(pos['notional'])
        
        # ì¡°ì • í•„ìš” ì—¬ë¶€ íŒë‹¨
        diff_value = target_short_value - current_short_value
        
        if abs(diff_value) < spot_position_value * 0.05:  # 5% ë¯¸ë§Œ ì°¨ì´ëŠ” ë¬´ì‹œ
            logger.info(f"í—¤ì§€ í¬ì§€ì…˜ ìœ ì§€ (í˜„ì¬: {current_short_value:.2f} USDT)")
            return
        
        # í¬ì§€ì…˜ ì¡°ì •
        current_price = self.exchange.fetch_ticker(symbol)['last']
        contracts_to_adjust = diff_value / current_price
        
        try:
            if contracts_to_adjust > 0:
                # í—¤ì§€ ì¦ê°€ (Short ì¶”ê°€)
                order = self.exchange.create_market_sell_order(symbol, abs(contracts_to_adjust))
                logger.info(f"í—¤ì§€ ì¦ê°€: {abs(contracts_to_adjust):.6f} BTC Short")
            else:
                # í—¤ì§€ ê°ì†Œ (Short ì²­ì‚°)
                order = self.exchange.create_market_buy_order(symbol, abs(contracts_to_adjust))
                logger.info(f"í—¤ì§€ ê°ì†Œ: {abs(contracts_to_adjust):.6f} BTC ì²­ì‚°")
        
        except Exception as e:
            logger.error(f"í—¤ì§€ ì¡°ì • ì‹¤íŒ¨: {e}")

# 4ì‹œê°„ë§ˆë‹¤ ì‹¤í–‰
def hedge_rebalance_task(spot_value, sentiment_score, hedging_manager):
    hedge_ratio = hedging_manager.calculate_hedge_ratio(sentiment_score)
    logger.info(f"ëª©í‘œ í—¤ì§€ ë¹„ìœ¨: {hedge_ratio*100:.1f}% (ê°ì„±: {sentiment_score:+.2f})")
    
    hedging_manager.adjust_hedge_position(
        'BTC/USDT:USDT',
        spot_value,
        hedge_ratio
    )
```

---

## 4ì‹œê°„ ì£¼ê¸° ë‰´ìŠ¤ ë¶„ì„ ìë™í™”

![](/images/2026-02-22-Advanced-Trading-Bot-DCA-Strategy/automation.jpg)

**í•˜ë£¨ 6íšŒ(4ì‹œê°„ë§ˆë‹¤)** ë‰´ìŠ¤ë¥¼ ìˆ˜ì§‘í•˜ê³  ê°ì„± ë¶„ì„ì„ ì‹¤í–‰í•©ë‹ˆë‹¤.

```python
# main.pyì— ì¶”ê°€
import schedule

def news_analysis_task(news_collector, sentiment_analyzer, signal_generator, notifier):
    """4ì‹œê°„ë§ˆë‹¤ ë‰´ìŠ¤ ë¶„ì„ + ì‹œê·¸ë„ ìƒì„±"""
    logger.info("ë‰´ìŠ¤ ë¶„ì„ ì‘ì—… ì‹œì‘")
    
    # 1. ë‰´ìŠ¤ ìˆ˜ì§‘
    news_list = news_collector.fetch_recent_news(hours=4)
    logger.info(f"ìˆ˜ì§‘ëœ ë‰´ìŠ¤: {len(news_list)}ê°œ")
    
    # 2. ê°ì„± ë¶„ì„
    sentiment_score = sentiment_analyzer.analyze_crypto_news(news_list)
    logger.info(f"ê°ì„± ì ìˆ˜: {sentiment_score:+.2f}")
    
    # 3. ì‹œê·¸ë„ ìƒì„±
    signal = signal_generator.generate_signal(news_list)
    logger.info(f"ìƒì„±ëœ ì‹œê·¸ë„: {signal}")
    
    # 4. ì•Œë¦¼ ë°œì†¡
    sentiment_emoji = "ğŸŸ¢" if sentiment_score > 0 else "ğŸ”´" if sentiment_score < 0 else "âšª"
    notifier.send(
        f"{sentiment_emoji} <b>4ì‹œê°„ ë‰´ìŠ¤ ë¶„ì„ ì™„ë£Œ</b>\n\n"
        f"ğŸ“° ìˆ˜ì§‘: {len(news_list)}ê°œ\n"
        f"ğŸ’­ ê°ì„±: {sentiment_score:+.2f}\n"
        f"ğŸ“Š ì‹œê·¸ë„: {signal}\n\n"
        f"ë‹¤ìŒ ë¶„ì„: 4ì‹œê°„ í›„"
    )

# ìŠ¤ì¼€ì¤„ ë“±ë¡
schedule.every(4).hours.do(
    news_analysis_task,
    news_collector,
    sentiment_analyzer,
    signal_generator,
    notifier
)
```

---

## PAPER ëª¨ë“œ êµ¬í˜„ (ëª¨ì˜ë§¤ë§¤)

ì‹¤ì „ íˆ¬ì… ì „ **ë°˜ë“œì‹œ PAPER ëª¨ë“œë¡œ ì¶©ë¶„íˆ ê²€ì¦**í•´ì•¼ í•©ë‹ˆë‹¤.

```python
# src/paper_trading.py
from datetime import datetime
from typing import Dict, List

class PaperTradingExchange:
    """ëª¨ì˜ ê±°ë˜ì†Œ (ì‹¤ì œ ì£¼ë¬¸ ì—†ì´ ì‹œë®¬ë ˆì´ì…˜)"""
    
    def __init__(self, initial_balance: float = 10_000_000):
        self.balance = {'USDT': initial_balance, 'BTC': 0.0}
        self.orders: List[Dict] = []
        self.trades: List[Dict] = []
    
    def create_market_buy_order(self, symbol: str, amount: float, price: float) -> Dict:
        """ì‹œì¥ê°€ ë§¤ìˆ˜ (ì‹œë®¬ë ˆì´ì…˜)"""
        cost = amount * price
        fee = cost * 0.001  # 0.1% ìˆ˜ìˆ˜ë£Œ
        
        if self.balance['USDT'] < cost + fee:
            raise Exception("ì”ê³  ë¶€ì¡±")
        
        self.balance['USDT'] -= (cost + fee)
        self.balance['BTC'] += amount
        
        trade = {
            'id': f"PAPER_{len(self.trades)}",
            'timestamp': datetime.now().isoformat(),
            'symbol': symbol,
            'side': 'buy',
            'amount': amount,
            'price': price,
            'cost': cost,
            'fee': fee,
        }
        self.trades.append(trade)
        
        return trade
    
    def create_market_sell_order(self, symbol: str, amount: float, price: float) -> Dict:
        """ì‹œì¥ê°€ ë§¤ë„ (ì‹œë®¬ë ˆì´ì…˜)"""
        if self.balance['BTC'] < amount:
            raise Exception("ë³´ìœ ëŸ‰ ë¶€ì¡±")
        
        proceeds = amount * price
        fee = proceeds * 0.001
        
        self.balance['BTC'] -= amount
        self.balance['USDT'] += (proceeds - fee)
        
        trade = {
            'id': f"PAPER_{len(self.trades)}",
            'timestamp': datetime.now().isoformat(),
            'symbol': symbol,
            'side': 'sell',
            'amount': amount,
            'price': price,
            'cost': proceeds,
            'fee': fee,
        }
        self.trades.append(trade)
        
        return trade
    
    def get_balance(self) -> Dict:
        """ì”ê³  ì¡°íšŒ"""
        return self.balance.copy()
    
    def get_trades(self) -> List[Dict]:
        """ê±°ë˜ ë‚´ì—­"""
        return self.trades.copy()

# ì‚¬ìš©
paper_mode = True  # í™˜ê²½ë³€ìˆ˜ë¡œ ê´€ë¦¬ ê¶Œì¥

if paper_mode:
    exchange = PaperTradingExchange(initial_balance=10_000_000)
else:
    exchange = ccxt.upbit({...})  # ì‹¤ê±°ë˜ì†Œ
```

---

## ì „ì²´ ì‹œìŠ¤í…œ í†µí•©

ëª¨ë“  ì»´í¬ë„ŒíŠ¸ë¥¼ í•˜ë‚˜ë¡œ í†µí•©í•œ ë©”ì¸ ì½”ë“œì…ë‹ˆë‹¤.

```python
# main.py
import schedule
import time
from loguru import logger
from dotenv import load_dotenv
import os

load_dotenv()

from src.dca_strategy import DCAManager
from src.phase_defense import PhaseDefenseManager, TradingPhase
from src.news_sentiment import NewsSentimentAnalyzer, HybridSignalGenerator
from src.news_collector import CryptoNewsCollector
from src.volatility_monitor import VolatilityMonitor
from src.order_manager import LimitOrderManager
from src.hedging_manager import BybitHedgingManager
from src.paper_trading import PaperTradingExchange
from src.notifier import TelegramNotifier

# ì„¤ì •
PAPER_MODE = os.getenv('PAPER_MODE', 'true').lower() == 'true'
SYMBOL = 'BTC/USDT'
INITIAL_CAPITAL = 10_000_000  # 1ì²œë§Œì›
BASE_PRICE = 50_000_000  # ì´ˆê¸° ì§„ì…ê°€ 5ì²œë§Œì›

def setup():
    """ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
    # Exchange
    if PAPER_MODE:
        exchange = PaperTradingExchange(INITIAL_CAPITAL)
        logger.warning("âš ï¸ PAPER MODE: ëª¨ì˜ë§¤ë§¤ ëª¨ë“œ")
    else:
        import ccxt
        exchange = ccxt.upbit({
            'apiKey': os.getenv('UPBIT_API_KEY'),
            'secret': os.getenv('UPBIT_SECRET'),
        })
    
    # Components
    dca_manager = DCAManager(INITIAL_CAPITAL * 0.5, BASE_PRICE)  # DCA ì˜ˆì‚° 50%
    notifier = TelegramNotifier()
    phase_defense = PhaseDefenseManager(dca_manager, notifier)
    
    news_collector = CryptoNewsCollector()
    sentiment_analyzer = NewsSentimentAnalyzer()
    signal_generator = HybridSignalGenerator(sentiment_analyzer)
    
    volatility_monitor = VolatilityMonitor(threshold_pct=3.0)
    order_manager = LimitOrderManager(exchange)
    
    hedging_manager = None
    if not PAPER_MODE:
        hedging_manager = BybitHedgingManager(
            os.getenv('BYBIT_API_KEY'),
            os.getenv('BYBIT_SECRET')
        )
    
    return {
        'exchange': exchange,
        'dca': dca_manager,
        'phase': phase_defense,
        'notifier': notifier,
        'news_collector': news_collector,
        'sentiment': sentiment_analyzer,
        'signal': signal_generator,
        'volatility': volatility_monitor,
        'orders': order_manager,
        'hedging': hedging_manager,
    }

def volatility_check_task(ctx):
    """1ë¶„ë§ˆë‹¤: ê¸‰ë³€ ê°ì§€"""
    current_price = 50_000_000  # ì‹¤ì œë¡œëŠ” exchange.fetch_ticker(SYMBOL)['last']
    result = ctx['volatility'].update(current_price)
    
    if result['alert']:
        emoji = "ğŸš€" if result['change_pct'] > 0 else "âš¡"
        ctx['notifier'].send(
            f"{emoji} <b>15ë¶„ ê¸‰ë³€!</b> {result['change_pct']:+.2f}%"
        )

def dca_check_task(ctx):
    """15ë¶„ë§ˆë‹¤: DCA íŠ¸ë¦¬ê±° ì²´í¬"""
    current_price = 50_000_000  # ì‹¤ì œ ê°€ê²©
    
    # Phase ì—…ë°ì´íŠ¸
    ctx['phase'].update_phase()
    
    # DCA ë ˆë²¨ ì²´í¬
    level = ctx['dca'].check_trigger(current_price)
    if level and ctx['phase'].phase == TradingPhase.DCA_ACTIVE:
        result = ctx['dca'].execute_dca(level, current_price)
        ctx['notifier'].send(
            f"ğŸ’§ <b>DCA Level {result['level']} ì‹¤í–‰</b>\n\n"
            f"ë§¤ìˆ˜ê°€: {result['buy_price']:,.0f}ì›\n"
            f"ìˆ˜ëŸ‰: {result['coins_bought']:.6f} BTC\n"
            f"í‰ë‹¨ê°€: {result['avg_price']:,.0f}ì›"
        )
    
    # ë°©ì–´ ì •ì±… ì²´í¬
    defense_action = ctx['phase'].check_defense_trigger(current_price, 0.1)
    if defense_action['action'] == 'LIQUIDATE_ALL':
        # ì „ëŸ‰ ì²­ì‚°
        logger.critical("ê¸´ê¸‰ ì²­ì‚° ì‹¤í–‰!")
        # exchange.create_market_sell_order(...)

def news_analysis_task(ctx):
    """4ì‹œê°„ë§ˆë‹¤: ë‰´ìŠ¤ ë¶„ì„ + í—¤ì§€ ì¡°ì •"""
    news_list = ctx['news_collector'].fetch_recent_news(hours=4)
    sentiment = ctx['sentiment'].analyze_crypto_news(news_list)
    signal = ctx['signal'].generate_signal(news_list)
    
    ctx['notifier'].send(
        f"ğŸ“° <b>ë‰´ìŠ¤ ë¶„ì„</b>\n\n"
        f"ìˆ˜ì§‘: {len(news_list)}ê°œ\n"
        f"ê°ì„±: {sentiment:+.2f}\n"
        f"ì‹œê·¸ë„: {signal}"
    )
    
    # í—¤ì§€ ì¡°ì • (ì‹¤ì „ ëª¨ë“œë§Œ)
    if ctx['hedging']:
        spot_value = 1_000_000  # ì‹¤ì œ í˜„ë¬¼ ê°€ì¹˜
        hedge_ratio = ctx['hedging'].calculate_hedge_ratio(sentiment)
        ctx['hedging'].adjust_hedge_position('BTC/USDT:USDT', spot_value, hedge_ratio)

def main():
    logger.add("logs/bot.log", rotation="1 day", retention="30 days")
    logger.info("ğŸ¤– ê³ ê¸‰ íŠ¸ë ˆì´ë”© ë´‡ ì‹œì‘")
    
    ctx = setup()
    ctx['notifier'].send("ğŸ¤– ë´‡ ì‹œì‘ (PAPER MODE)" if PAPER_MODE else "ğŸ¤– ë´‡ ì‹œì‘ (LIVE)")
    
    # ìŠ¤ì¼€ì¤„ ë“±ë¡
    schedule.every(1).minutes.do(volatility_check_task, ctx)
    schedule.every(15).minutes.do(dca_check_task, ctx)
    schedule.every(4).hours.do(news_analysis_task, ctx)
    
    # ì¦‰ì‹œ 1íšŒ ì‹¤í–‰
    news_analysis_task(ctx)
    
    while True:
        schedule.run_pending()
        time.sleep(1)

if __name__ == "__main__":
    main()
```

---

## ë³´ì•ˆ ì²´í¬ë¦¬ìŠ¤íŠ¸ (ë°°í¬ ì „ í•„ìˆ˜)

```
API ë³´ì•ˆ
  â˜‘ Upbit/Bybit API í‚¤ ì¶œê¸ˆ ê¶Œí•œ ë¹„í™œì„±í™”
  â˜‘ API í‚¤ IP í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ì„¤ì •
  â˜‘ .env íŒŒì¼ ê¶Œí•œ 600 ì„¤ì • (chmod 600 .env)
  â˜‘ .gitignoreì— .env, logs/ í¬í•¨
  â˜‘ GitHub ë“± ê³µê°œ ì €ì¥ì†Œì— API í‚¤ ì ˆëŒ€ ì—…ë¡œë“œ ê¸ˆì§€

í™˜ê²½ ë³€ìˆ˜ (.env ì˜ˆì‹œ)
  PAPER_MODE=true
  UPBIT_API_KEY=YOUR_KEY_HERE
  UPBIT_SECRET=YOUR_SECRET_HERE
  BYBIT_API_KEY=YOUR_KEY_HERE
  BYBIT_SECRET=YOUR_SECRET_HERE
  ANTHROPIC_API_KEY=YOUR_KEY_HERE
  TELEGRAM_BOT_TOKEN=YOUR_TOKEN
  TELEGRAM_CHAT_ID=YOUR_CHAT_ID

í…ŒìŠ¤íŠ¸ ë‹¨ê³„
  â˜‘ PAPER ëª¨ë“œë¡œ ìµœì†Œ 2ì£¼ ê²€ì¦
  â˜‘ DCA 6ë‹¨ê³„ íŠ¸ë¦¬ê±° ì •ìƒ ë™ì‘ í™•ì¸
  â˜‘ ë°©ì–´ ì •ì±… (-3%/-5%/-8%) ì‹œë®¬ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸
  â˜‘ ë‰´ìŠ¤ ë¶„ì„ API í• ë‹¹ëŸ‰ í™•ì¸ (Claude API)
  â˜‘ í—¤ì§€ ë¹„ìœ¨ ê³„ì‚° ë¡œì§ ê²€ì¦

ìš´ì˜ ë‹¨ê³„
  â˜‘ systemd ì„œë¹„ìŠ¤ ë“±ë¡ (ìë™ ì¬ì‹œì‘)
  â˜‘ ë¡œê·¸ ë¡œí…Œì´ì…˜ ì„¤ì •
  â˜‘ ì¼ì¼ ë¦¬í¬íŠ¸ ìë™ ë°œì†¡
  â˜‘ ë¹„ìƒ ì •ì§€ ë°©ë²• ìˆ™ì§€
```

---

## ì„±ê³¼ ì§€í‘œ ë° ëª¨ë‹ˆí„°ë§

### ì¶”ì í•  í•µì‹¬ ì§€í‘œ

| ì§€í‘œ | ëª©í‘œ | í˜„ì¬ (PAPER) |
|------|------|--------------|
| ì´ ìˆ˜ìµë¥  | +20% (ì—°ê°„) | ê²€ì¦ ì¤‘ |
| ìŠ¹ë¥  | 40~50% | ê²€ì¦ ì¤‘ |
| ìµœëŒ€ ë‚™í­(MDD) | -15% ì´í•˜ | ê²€ì¦ ì¤‘ |
| ìƒ¤í”„ ë¹„ìœ¨ | 1.5 ì´ìƒ | ê²€ì¦ ì¤‘ |
| DCA í‰ê·  ì‹¤í–‰ íšŸìˆ˜ | ì£¼ 1~2íšŒ | ê²€ì¦ ì¤‘ |
| ë°©ì–´ ì •ì±… ë°œë™ | ì›” 0~1íšŒ | ê²€ì¦ ì¤‘ |

### ì¼ì¼ ë¦¬í¬íŠ¸ ì˜ˆì‹œ

```
ğŸ“Š ì¼ì¼ íŠ¸ë ˆì´ë”© ë¦¬í¬íŠ¸

ğŸ—“ï¸ ë‚ ì§œ: 2026-02-22
ğŸ’° ì”ê³ : 10,234,500ì› (+2.3%)
ğŸ“ˆ BTC ë³´ìœ : 0.0152 BTC
ğŸ’µ í‰ë‹¨ê°€: 49,850,000ì›
ğŸ’µ í˜„ì¬ê°€: 51,200,000ì› (+2.7%)

ğŸ“° ë‰´ìŠ¤ ë¶„ì„: 6íšŒ
   ìµœê·¼ ê°ì„±: +0.3 (ê¸ì •)
   í˜„ì¬ ì‹œê·¸ë„: HOLD

ğŸ›¡ï¸ í—¤ì§€ ìƒíƒœ
   í—¤ì§€ ë¹„ìœ¨: 45% (NEUTRAL)
   ì„ ë¬¼ í¬ì§€ì…˜: -0.0068 BTC Short

ğŸ”” ì´ë²¤íŠ¸
   â€¢ 10:15 - 15ë¶„ ê¸‰ë³€ ê°ì§€ (+3.2%)
   â€¢ 14:00 - ë‰´ìŠ¤ ë¶„ì„ ì™„ë£Œ (ê°ì„± +0.4)

âš™ï¸ ë´‡ ìƒíƒœ: ì •ìƒ ìš´ì˜ ì¤‘
```

---

## í–¥í›„ ê°œì„  ë°©í–¥

### Phase 1 (ê²€ì¦ ì™„ë£Œ í›„)
- [ ] PAPER ëª¨ë“œ 2ì£¼ ê²€ì¦ ì™„ë£Œ
- [ ] ì‹¤ê³„ì¢Œ ì†Œì•¡(50ë§Œì›) íˆ¬ì…
- [ ] 1ê°œì›” ì‹¤ì „ ìš´ì˜ ë°ì´í„° ìˆ˜ì§‘

### Phase 2 (ì•ˆì •í™” í›„)
- [ ] ë¨¸ì‹ ëŸ¬ë‹ ê¸°ë°˜ ì‹œê·¸ë„ ê°•í™” (XGBoost, LSTM)
- [ ] ë©€í‹° ì½”ì¸ ì§€ì› (ETH, SOL, BNB)
- [ ] ê±°ë˜ì†Œ ì°¨ìµê±°ë˜ í†µí•© (ê¹€í”„ í™œìš©)

### Phase 3 (ê³ ë„í™”)
- [ ] ì˜¨ì²´ì¸ ë°ì´í„° ë¶„ì„ í†µí•© (Glassnode API)
- [ ] ì†Œì…œ ë¯¸ë””ì–´ ê°ì„± ë¶„ì„ ì¶”ê°€ (Twitter, Reddit)
- [ ] ìë™ íŒŒë¼ë¯¸í„° ìµœì í™” (Optuna)

---

## ë§ˆë¬´ë¦¬

ì´ ê¸€ì—ì„œ ë‹¤ë£¬ ì „ëµë“¤ì€ **ì‹¤ì œë¡œ PAPER ëª¨ë“œì—ì„œ ê²€ì¦ ì¤‘**ì…ë‹ˆë‹¤. ë‹¨ìˆœí•œ ì´ë¡ ì´ ì•„ë‹ˆë¼, ì½”ë“œë¡œ êµ¬í˜„í•˜ê³  ì‹œì¥ ë°ì´í„°ë¡œ í…ŒìŠ¤íŠ¸í•˜ëŠ” ì‹¤ì „ í”„ë¡œì íŠ¸ì…ë‹ˆë‹¤.

**í•µì‹¬ êµí›ˆ**:
1. **DCAëŠ” ë§ˆë²•ì´ ì•„ë‹ˆë‹¤** - ì˜ˆì‚° ê´€ë¦¬ ì—†ì´ ë¬´í•œ ë¬¼íƒ€ê¸°ëŠ” íŒŒì‚°ìœ¼ë¡œ ê°€ëŠ” ê¸¸
2. **ë‰´ìŠ¤ëŠ” ì¤‘ìš”í•˜ë‹¤** - ì‹œì¥ ì‹¬ë¦¬ë¥¼ ë¬´ì‹œí•œ ê¸°ìˆ ì  ë¶„ì„ë§Œìœ¼ë¡œëŠ” ë¶€ì¡±
3. **í—¤ì§•ì€ ë³´í—˜ì´ë‹¤** - ë¹„ìš©ì´ ë“¤ì§€ë§Œ ê¸‰ë½ì¥ì—ì„œ ê³„ì¢Œë¥¼ ì§€í‚´
4. **ìë™í™”ëŠ” ì–‘ë‚ ì˜ ê²€** - ì˜ëª» ì„¤ì •í•˜ë©´ ì†ì‹¤ë„ ìë™í™”ë¨
5. **ê²€ì¦ ì—†ì´ ì‹¤ì „ ê¸ˆì§€** - PAPER ëª¨ë“œëŠ” ê·€ì°®ì•„ë„ ë°˜ë“œì‹œ ê±°ì¹  ê²ƒ

ì•”í˜¸í™”í ì‹œì¥ì€ 24ì‹œê°„ ëŒì•„ê°€ì§€ë§Œ, ì—¬ëŸ¬ë¶„ì˜ ê±´ê°•ê³¼ ì •ì‹ ì€ 24ì‹œê°„ ëŒì•„ê°ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. **ë´‡ì—ê²Œ ë§¡ê¸¸ ê±´ ë§¡ê¸°ë˜, ë§¹ì‹ í•˜ì§€ ë§ˆì„¸ìš”**. ì •ê¸°ì ìœ¼ë¡œ ì ê²€í•˜ê³ , ì˜ì‹¬ìŠ¤ëŸ¬ìš´ ì›€ì§ì„ì´ ë³´ì´ë©´ ì¦‰ì‹œ ì¤‘ë‹¨í•  ìš©ê¸°ë¥¼ ê°€ì§€ì„¸ìš”.

í–‰ìš´ì„ ë¹•ë‹ˆë‹¤! ğŸš€

---

**ì°¸ê³  ìë£Œ:**
- [íŠ¸ë ˆì´ë”© ë´‡ ê°œë°œ ì™„ë²½ ê°€ì´ë“œ](/blog/trading-bot-development-guide)
- [Anthropic Claude API ë¬¸ì„œ](https://docs.anthropic.com/)
- [ccxt ê³µì‹ ë¬¸ì„œ](https://docs.ccxt.com/)
- [Bybit API ë¬¸ì„œ](https://bybit-exchange.github.io/docs/)
- [ì¼ˆë¦¬ ê¸°ì¤€(Kelly Criterion) í¬ì§€ì…˜ ì‚¬ì´ì§•](https://en.wikipedia.org/wiki/Kelly_criterion)

---

*ë³¸ ê¸€ì€ êµìœ¡ ëª©ì ìœ¼ë¡œ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹¤ì œ íˆ¬ìëŠ” ë³¸ì¸ì˜ ì±…ì„ í•˜ì— ì§„í–‰í•˜ì‹œê³ , íˆ¬ì ì›ê¸ˆ ì†ì‹¤ì— í•­ìƒ ì£¼ì˜í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤. ì œì‹œëœ ì „ëµì€ PAPER ëª¨ë“œ ê²€ì¦ ì¤‘ì´ë©°, ì‹¤ì „ ì„±ê³¼ë¥¼ ë³´ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.*
